{"ast":null,"code":"import { isFunction } from './isFunction';\nimport { hasEntity } from './hasEntity';\nimport { isPlainObject } from './isPlainObject';\n// @internal\nexport function updateEntities({\n  state,\n  ids,\n  idKey,\n  newStateOrFn,\n  preUpdateEntity,\n  producerFn,\n  onEntityIdChanges\n}) {\n  const updatedEntities = {};\n  let isUpdatingIdKey = false;\n  let idToUpdate;\n  for (const id of ids) {\n    // if the entity doesn't exist don't do anything\n    if (hasEntity(state.entities, id) === false) {\n      continue;\n    }\n    const oldEntity = state.entities[id];\n    let newState;\n    if (isFunction(newStateOrFn)) {\n      newState = isFunction(producerFn) ? producerFn(oldEntity, newStateOrFn) : newStateOrFn(oldEntity);\n    } else {\n      newState = newStateOrFn;\n    }\n    const isIdChanged = newState.hasOwnProperty(idKey) && newState[idKey] !== oldEntity[idKey];\n    let newEntity;\n    idToUpdate = id;\n    if (isIdChanged) {\n      isUpdatingIdKey = true;\n      idToUpdate = newState[idKey];\n    }\n    const merged = {\n      ...oldEntity,\n      ...newState\n    };\n    if (isPlainObject(oldEntity)) {\n      newEntity = merged;\n    } else {\n      /**\n       * In case that new state is class of it's own, there's\n       * a possibility that it will be different than the old\n       * class.\n       * For example, Old state is an instance of animal class\n       * and new state is instance of person class.\n       * To avoid run over new person class with the old animal\n       * class we check if the new state is a class of it's own.\n       * If so, use it. Otherwise, use the old state class\n       */\n      if (isPlainObject(newState)) {\n        newEntity = new oldEntity.constructor(merged);\n      } else {\n        newEntity = new newState.constructor(merged);\n      }\n    }\n    updatedEntities[idToUpdate] = preUpdateEntity(oldEntity, newEntity);\n  }\n  let updatedIds = state.ids;\n  let stateEntities = state.entities;\n  if (isUpdatingIdKey) {\n    const [id] = ids;\n    const {\n      [id]: deletedEntity,\n      ...rest\n    } = state.entities;\n    stateEntities = rest;\n    updatedIds = state.ids.map(current => current === id ? idToUpdate : current);\n    onEntityIdChanges(id, idToUpdate);\n  }\n  return {\n    ...state,\n    entities: {\n      ...stateEntities,\n      ...updatedEntities\n    },\n    ids: updatedIds\n  };\n}\n//# sourceMappingURL=updateEntities.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}