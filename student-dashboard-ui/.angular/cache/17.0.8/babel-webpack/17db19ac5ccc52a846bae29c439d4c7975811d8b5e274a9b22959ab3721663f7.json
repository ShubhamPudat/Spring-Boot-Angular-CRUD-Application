{"ast":null,"code":"var _a, _b;\nimport { __decorate, __metadata } from \"tslib\";\nimport { Subject } from 'rxjs';\nimport { logAction, setAction } from './actions';\nimport { addEntities } from './addEntities';\nimport { coerceArray } from './coerceArray';\nimport { DEFAULT_ID_KEY } from './defaultIDKey';\nimport { EntityActions } from './entityActions';\nimport { isDev } from './env';\nimport { getActiveEntities } from './getActiveEntities';\nimport { getInitialEntitiesState } from './getInitialEntitiesState';\nimport { hasEntity } from './hasEntity';\nimport { isDefined } from './isDefined';\nimport { isEmpty } from './isEmpty';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isUndefined } from './isUndefined';\nimport { removeEntities } from './removeEntities';\nimport { setEntities } from './setEntities';\nimport { Store } from './store';\nimport { transaction } from './transaction';\nimport { updateEntities } from './updateEntities';\n/**\n *\n * Store for managing a collection of entities\n *\n * @example\n *\n * export interface WidgetsState extends EntityState<Widget> { }\n *\n * @StoreConfig({ name: 'widgets' })\n *  export class WidgetsStore extends EntityStore<WidgetsState> {\n *   constructor() {\n *     super();\n *   }\n * }\n *\n *\n */\nexport class EntityStore extends Store {\n  constructor(initialState = {}, options = {}) {\n    super({\n      ...getInitialEntitiesState(),\n      ...initialState\n    }, options);\n    this.options = options;\n    this.entityActions = new Subject();\n    this.entityIdChanges = new Subject();\n  }\n  // @internal\n  get selectEntityAction$() {\n    return this.entityActions.asObservable();\n  }\n  // @internal\n  get selectEntityIdChanges$() {\n    return this.entityIdChanges.asObservable();\n  }\n  // @internal\n  get idKey() {\n    return this.config.idKey || this.options.idKey || DEFAULT_ID_KEY;\n  }\n  /**\n   *\n   * Replace current collection with provided collection\n   *\n   * @example\n   *\n   * this.store.set([Entity, Entity])\n   * this.store.set({ids: [], entities: {}})\n   * this.store.set({ 1: {}, 2: {}})\n   *\n   */\n  set(entities, options = {}) {\n    if (isNil(entities)) return;\n    isDev() && setAction('Set Entity');\n    const isNativePreAdd = this.akitaPreAddEntity === EntityStore.prototype.akitaPreAddEntity;\n    this.setHasCache(true, {\n      restartTTL: true\n    });\n    this._setState(state => {\n      const newState = setEntities({\n        state,\n        entities,\n        idKey: this.idKey,\n        preAddEntity: this.akitaPreAddEntity.bind(this),\n        isNativePreAdd\n      });\n      if (isUndefined(options.activeId) === false) {\n        newState.active = options.activeId;\n      }\n      return newState;\n    });\n    if (this.hasInitialUIState()) {\n      this.handleUICreation();\n    }\n    this.entityActions.next({\n      type: EntityActions.Set,\n      ids: this.ids\n    });\n  }\n  /**\n   * Add entities\n   *\n   * @example\n   *\n   * this.store.add([Entity, Entity])\n   * this.store.add(Entity)\n   * this.store.add(Entity, { prepend: true })\n   *\n   * this.store.add(Entity, { loading: false })\n   */\n  add(entities, options = {\n    loading: false\n  }) {\n    const collection = coerceArray(entities);\n    if (isEmpty(collection)) return;\n    const data = addEntities({\n      state: this._value(),\n      preAddEntity: this.akitaPreAddEntity.bind(this),\n      entities: collection,\n      idKey: this.idKey,\n      options\n    });\n    if (data) {\n      isDev() && setAction('Add Entity');\n      data.newState.loading = options.loading;\n      this._setState(() => data.newState);\n      if (this.hasInitialUIState()) {\n        this.handleUICreation(true);\n      }\n      this.entityActions.next({\n        type: EntityActions.Add,\n        ids: data.newIds\n      });\n    }\n  }\n  update(idsOrFnOrState, newStateOrFn) {\n    if (isUndefined(newStateOrFn)) {\n      super.update(idsOrFnOrState);\n      return;\n    }\n    let ids = [];\n    if (isFunction(idsOrFnOrState)) {\n      // We need to filter according the predicate function\n      ids = this.ids.filter(id => idsOrFnOrState(this.entities[id]));\n    } else {\n      // If it's nil we want all of them\n      ids = isNil(idsOrFnOrState) ? this.ids : coerceArray(idsOrFnOrState);\n    }\n    if (isEmpty(ids)) return;\n    isDev() && setAction('Update Entity', ids);\n    let entityIdChanged;\n    this._setState(state => updateEntities({\n      idKey: this.idKey,\n      ids,\n      preUpdateEntity: this.akitaPreUpdateEntity.bind(this),\n      state,\n      newStateOrFn,\n      producerFn: this._producerFn,\n      onEntityIdChanges: (oldId, newId) => {\n        entityIdChanged = {\n          oldId,\n          newId\n        };\n        this.entityIdChanges.next({\n          ...entityIdChanged,\n          pending: true\n        });\n      }\n    }));\n    if (entityIdChanged) {\n      this.entityIdChanges.next({\n        ...entityIdChanged,\n        pending: false\n      });\n    }\n    this.entityActions.next({\n      type: EntityActions.Update,\n      ids\n    });\n  }\n  upsert(ids, newState, onCreate, options = {}) {\n    const toArray = coerceArray(ids);\n    const predicate = isUpdate => id => hasEntity(this.entities, id) === isUpdate;\n    const baseClass = isFunction(onCreate) ? options.baseClass : onCreate ? onCreate.baseClass : undefined;\n    const isClassBased = isFunction(baseClass);\n    const updateIds = toArray.filter(predicate(true));\n    const newEntities = toArray.filter(predicate(false)).map(id => {\n      const newStateObj = typeof newState === 'function' ? newState({}) : newState;\n      const entity = isFunction(onCreate) ? onCreate(id, newStateObj) : newStateObj;\n      const withId = {\n        ...entity,\n        [this.idKey]: id\n      };\n      if (isClassBased) {\n        return new baseClass(withId);\n      }\n      return withId;\n    });\n    // it can be any of the three types\n    this.update(updateIds, newState);\n    this.add(newEntities);\n    isDev() && logAction('Upsert Entity');\n  }\n  /**\n   *\n   * Upsert entity collection (idKey must be present)\n   *\n   * @example\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }]);\n   *\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { loading: true  });\n   * store.upsertMany([ { id: 1 }, { id: 2 }], { baseClass: Todo  });\n   *\n   */\n  upsertMany(entities, options = {}) {\n    const addedIds = [];\n    const updatedIds = [];\n    const updatedEntities = {};\n    // Update the state directly to optimize performance\n    for (const entity of entities) {\n      const withPreCheckHook = this.akitaPreCheckEntity(entity);\n      const id = withPreCheckHook[this.idKey];\n      if (hasEntity(this.entities, id)) {\n        const prev = this._value().entities[id];\n        const merged = {\n          ...this._value().entities[id],\n          ...withPreCheckHook\n        };\n        const next = options.baseClass ? new options.baseClass(merged) : merged;\n        const withHook = this.akitaPreUpdateEntity(prev, next);\n        const nextId = withHook[this.idKey];\n        updatedEntities[nextId] = withHook;\n        updatedIds.push(nextId);\n      } else {\n        const newEntity = options.baseClass ? new options.baseClass(withPreCheckHook) : withPreCheckHook;\n        const withHook = this.akitaPreAddEntity(newEntity);\n        const nextId = withHook[this.idKey];\n        addedIds.push(nextId);\n        updatedEntities[nextId] = withHook;\n      }\n    }\n    isDev() && logAction('Upsert Many');\n    this._setState(state => ({\n      ...state,\n      ids: addedIds.length ? [...state.ids, ...addedIds] : state.ids,\n      entities: {\n        ...state.entities,\n        ...updatedEntities\n      },\n      loading: !!options.loading\n    }));\n    updatedIds.length && this.entityActions.next({\n      type: EntityActions.Update,\n      ids: updatedIds\n    });\n    addedIds.length && this.entityActions.next({\n      type: EntityActions.Add,\n      ids: addedIds\n    });\n    if (addedIds.length && this.hasUIStore()) {\n      this.handleUICreation(true);\n    }\n  }\n  /**\n   *\n   * Replace one or more entities (except the id property)\n   *\n   *\n   * @example\n   *\n   * this.store.replace(5, newEntity)\n   * this.store.replace([1,2,3], newEntity)\n   */\n  replace(ids, newState) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const replaced = {};\n    for (const id of toArray) {\n      replaced[id] = {\n        ...newState,\n        [this.idKey]: id\n      };\n    }\n    isDev() && setAction('Replace Entity', ids);\n    this._setState(state => ({\n      ...state,\n      entities: {\n        ...state.entities,\n        ...replaced\n      }\n    }));\n  }\n  /**\n   *\n   * Move entity inside the collection\n   *\n   *\n   * @example\n   *\n   * this.store.move(fromIndex, toIndex)\n   */\n  move(from, to) {\n    const ids = this.ids.slice();\n    ids.splice(to < 0 ? ids.length + to : to, 0, ids.splice(from, 1)[0]);\n    isDev() && setAction('Move Entity');\n    this._setState(state => ({\n      ...state,\n      // Change the entities reference so that selectAll emit\n      entities: {\n        ...state.entities\n      },\n      ids\n    }));\n  }\n  remove(idsOrFn) {\n    if (isEmpty(this.ids)) return;\n    const idPassed = isDefined(idsOrFn);\n    // null means remove all\n    let ids = [];\n    if (isFunction(idsOrFn)) {\n      ids = this.ids.filter(entityId => idsOrFn(this.entities[entityId]));\n    } else {\n      ids = idPassed ? coerceArray(idsOrFn) : this.ids;\n    }\n    if (isEmpty(ids)) return;\n    isDev() && setAction('Remove Entity', ids);\n    this._setState(state => removeEntities({\n      state,\n      ids\n    }));\n    if (!idPassed) {\n      this.setHasCache(false);\n    }\n    this.handleUIRemove(ids);\n    this.entityActions.next({\n      type: EntityActions.Remove,\n      ids\n    });\n  }\n  /**\n   *\n   * Update the active entity\n   *\n   * @example\n   *\n   * this.store.updateActive({ completed: true })\n   * this.store.updateActive(active => {\n   *   return {\n   *     config: {\n   *      ..active.config,\n   *      date\n   *     }\n   *   }\n   * })\n   */\n  updateActive(newStateOrCallback) {\n    const ids = coerceArray(this.active);\n    isDev() && setAction('Update Active', ids);\n    this.update(ids, newStateOrCallback);\n  }\n  setActive(idOrOptions) {\n    const active = getActiveEntities(idOrOptions, this.ids, this.active);\n    if (active === undefined) {\n      return;\n    }\n    isDev() && setAction('Set Active', active);\n    this._setActive(active);\n  }\n  /**\n   * Add active entities\n   *\n   * @example\n   *\n   * store.addActive(2);\n   * store.addActive([3, 4, 5]);\n   */\n  addActive(ids) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const everyExist = toArray.every(id => this.active.indexOf(id) > -1);\n    if (everyExist) return;\n    isDev() && setAction('Add Active', ids);\n    this._setState(state => {\n      /** Protect against case that one of the items in the array exist */\n      const uniques = Array.from(new Set([...state.active, ...toArray]));\n      return {\n        ...state,\n        active: uniques\n      };\n    });\n  }\n  /**\n   * Remove active entities\n   *\n   * @example\n   *\n   * store.removeActive(2)\n   * store.removeActive([3, 4, 5])\n   */\n  removeActive(ids) {\n    const toArray = coerceArray(ids);\n    if (isEmpty(toArray)) return;\n    const someExist = toArray.some(id => this.active.indexOf(id) > -1);\n    if (!someExist) return;\n    isDev() && setAction('Remove Active', ids);\n    this._setState(state => {\n      return {\n        ...state,\n        active: Array.isArray(state.active) ? state.active.filter(currentId => toArray.indexOf(currentId) === -1) : null\n      };\n    });\n  }\n  /**\n   * Toggle active entities\n   *\n   * @example\n   *\n   * store.toggle(2)\n   * store.toggle([3, 4, 5])\n   */\n  toggleActive(ids) {\n    const toArray = coerceArray(ids);\n    const filterExists = remove => id => this.active.includes(id) === remove;\n    const remove = toArray.filter(filterExists(true));\n    const add = toArray.filter(filterExists(false));\n    this.removeActive(remove);\n    this.addActive(add);\n    isDev() && logAction('Toggle Active');\n  }\n  /**\n   *\n   * Create sub UI store for managing Entity's UI state\n   *\n   * @example\n   *\n   * export type ProductUI = {\n   *   isLoading: boolean;\n   *   isOpen: boolean\n   * }\n   *\n   * interface ProductsUIState extends EntityState<ProductUI> {}\n   *\n   * export class ProductsStore EntityStore<ProductsState, Product> {\n   *   ui: EntityUIStore<ProductsUIState, ProductUI>;\n   *\n   *   constructor() {\n   *     super();\n   *     this.createUIStore();\n   *   }\n   *\n   * }\n   */\n  createUIStore(initialState = {}, storeConfig = {}) {\n    const defaults = {\n      name: `UI/${this.storeName}`,\n      idKey: this.idKey\n    };\n    this.ui = new EntityUIStore(initialState, {\n      ...defaults,\n      ...storeConfig\n    });\n    return this.ui;\n  }\n  // @internal\n  destroy() {\n    super.destroy();\n    if (this.ui instanceof EntityStore) {\n      this.ui.destroy();\n    }\n    this.entityActions.complete();\n  }\n  // @internal\n  akitaPreUpdateEntity(_, nextEntity) {\n    return nextEntity;\n  }\n  // @internal\n  akitaPreAddEntity(newEntity) {\n    return newEntity;\n  }\n  // @internal\n  akitaPreCheckEntity(newEntity) {\n    return newEntity;\n  }\n  get ids() {\n    return this._value().ids;\n  }\n  get entities() {\n    return this._value().entities;\n  }\n  get active() {\n    return this._value().active;\n  }\n  _setActive(ids) {\n    this._setState(state => {\n      return {\n        ...state,\n        active: ids\n      };\n    });\n  }\n  handleUICreation(add = false) {\n    const ids = this.ids;\n    const isFunc = isFunction(this.ui._akitaCreateEntityFn);\n    let uiEntities;\n    const createFn = id => {\n      const current = this.entities[id];\n      const ui = isFunc ? this.ui._akitaCreateEntityFn(current) : this.ui._akitaCreateEntityFn;\n      return {\n        [this.idKey]: current[this.idKey],\n        ...ui\n      };\n    };\n    if (add) {\n      uiEntities = this.ids.filter(id => isUndefined(this.ui.entities[id])).map(createFn);\n    } else {\n      uiEntities = ids.map(createFn);\n    }\n    add ? this.ui.add(uiEntities) : this.ui.set(uiEntities);\n  }\n  hasInitialUIState() {\n    return this.hasUIStore() && isUndefined(this.ui._akitaCreateEntityFn) === false;\n  }\n  handleUIRemove(ids) {\n    if (this.hasUIStore()) {\n      this.ui.remove(ids);\n    }\n  }\n  hasUIStore() {\n    return this.ui instanceof EntityUIStore;\n  }\n}\n__decorate([transaction(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object, Object, Object, Object]), __metadata(\"design:returntype\", void 0)], EntityStore.prototype, \"upsert\", null);\n__decorate([transaction(), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [typeof (_b = typeof T !== \"undefined\" && T) === \"function\" ? _b : Object]), __metadata(\"design:returntype\", void 0)], EntityStore.prototype, \"toggleActive\", null);\n// @internal\nexport class EntityUIStore extends EntityStore {\n  constructor(initialState = {}, storeConfig = {}) {\n    super(initialState, storeConfig);\n  }\n  /**\n   *\n   * Set the initial UI entity state. This function will determine the entity's\n   * initial state when we call `set()` or `add()`.\n   *\n   * @example\n   *\n   * constructor() {\n   *   super();\n   *   this.createUIStore().setInitialEntityState(entity => ({ isLoading: false, isOpen: true }));\n   *   this.createUIStore().setInitialEntityState({ isLoading: false, isOpen: true });\n   * }\n   *\n   */\n  setInitialEntityState(createFn) {\n    this._akitaCreateEntityFn = createFn;\n  }\n}\n//# sourceMappingURL=entityStore.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}