{"ast":null,"code":"import { from, isObservable, of, ReplaySubject } from 'rxjs';\nimport { filter, map, skip } from 'rxjs/operators';\nimport { setAction } from './actions';\nimport { $$addStore, $$deleteStore } from './dispatchers';\nimport { getValue } from './getValueByString';\nimport { isFunction } from './isFunction';\nimport { isNil } from './isNil';\nimport { isObject } from './isObject';\nimport { hasLocalStorage, hasSessionStorage, isNotBrowser } from './root';\nimport { setValue } from './setValueByString';\nimport { __stores__ } from './stores';\nlet skipStorageUpdate = false;\nconst _persistStateInit = new ReplaySubject(1);\nexport function selectPersistStateInit() {\n  return _persistStateInit.asObservable();\n}\nexport function setSkipStorageUpdate(skip) {\n  skipStorageUpdate = skip;\n}\nexport function getSkipStorageUpdate() {\n  return skipStorageUpdate;\n}\nfunction isPromise(v) {\n  return v && isFunction(v.then);\n}\nfunction observify(asyncOrValue) {\n  if (isPromise(asyncOrValue) || isObservable(asyncOrValue)) {\n    return from(asyncOrValue);\n  }\n  return of(asyncOrValue);\n}\nexport function persistState(params) {\n  const defaults = {\n    key: 'AkitaStores',\n    enableInNonBrowser: false,\n    storage: !hasLocalStorage() ? params.storage : localStorage,\n    deserialize: JSON.parse,\n    serialize: JSON.stringify,\n    include: [],\n    select: [],\n    persistOnDestroy: false,\n    preStorageUpdate: function (storeName, state) {\n      return state;\n    },\n    preStoreUpdate: function (storeName, state) {\n      return state;\n    },\n    skipStorageUpdate: getSkipStorageUpdate,\n    preStorageUpdateOperator: () => source => source\n  };\n  const {\n    storage,\n    enableInNonBrowser,\n    deserialize,\n    serialize,\n    include,\n    select,\n    key,\n    preStorageUpdate,\n    persistOnDestroy,\n    preStorageUpdateOperator,\n    preStoreUpdate,\n    skipStorageUpdate\n  } = Object.assign({}, defaults, params);\n  if (isNotBrowser && !enableInNonBrowser || !storage) return;\n  const hasInclude = include.length > 0;\n  const hasSelect = select.length > 0;\n  let includeStores;\n  let selectStores;\n  if (hasInclude) {\n    includeStores = include.reduce((acc, path) => {\n      if (isFunction(path)) {\n        acc.fns.push(path);\n      } else {\n        const storeName = path.split('.')[0];\n        acc[storeName] = path;\n      }\n      return acc;\n    }, {\n      fns: []\n    });\n  }\n  if (hasSelect) {\n    selectStores = select.reduce((acc, selectFn) => {\n      acc[selectFn.storeName] = selectFn;\n      return acc;\n    }, {});\n  }\n  let stores = {};\n  let acc = {};\n  let subscriptions = [];\n  const buffer = [];\n  function _save(v) {\n    observify(v).subscribe(() => {\n      const next = buffer.shift();\n      next && _save(next);\n    });\n  }\n  // when we use the local/session storage we perform the serialize, otherwise we let the passed storage implementation to do it\n  const isLocalStorage = hasLocalStorage() && storage === localStorage || hasSessionStorage() && storage === sessionStorage;\n  observify(storage.getItem(key)).subscribe(value => {\n    let storageState = isObject(value) ? value : deserialize(value || '{}');\n    function save(storeCache) {\n      storageState['$cache'] = {\n        ...(storageState['$cache'] || {}),\n        ...storeCache\n      };\n      storageState = Object.assign({}, storageState, acc);\n      buffer.push(storage.setItem(key, isLocalStorage ? serialize(storageState) : storageState));\n      _save(buffer.shift());\n    }\n    function subscribe(storeName, path) {\n      stores[storeName] = __stores__[storeName]._select(state => getValue(state, path)).pipe(skip(1), map(store => {\n        if (hasSelect && selectStores[storeName]) {\n          return selectStores[storeName](store);\n        }\n        return store;\n      }), filter(() => skipStorageUpdate() === false), preStorageUpdateOperator()).subscribe(data => {\n        acc[storeName] = preStorageUpdate(storeName, data);\n        Promise.resolve().then(() => save({\n          [storeName]: __stores__[storeName]._cache().getValue()\n        }));\n      });\n    }\n    function setInitial(storeName, store, path) {\n      if (storeName in storageState) {\n        setAction('@PersistState');\n        store._setState(state => {\n          return setValue(state, path, preStoreUpdate(storeName, storageState[storeName], state));\n        });\n        const hasCache = storageState['$cache'] ? storageState['$cache'][storeName] : false;\n        __stores__[storeName].setHasCache(hasCache, {\n          restartTTL: true\n        });\n      }\n    }\n    subscriptions.push($$deleteStore.subscribe(storeName => {\n      if (stores[storeName]) {\n        if (persistOnDestroy === false) {\n          save({\n            [storeName]: false\n          });\n        }\n        stores[storeName].unsubscribe();\n        delete stores[storeName];\n      }\n    }));\n    subscriptions.push($$addStore.subscribe(storeName => {\n      if (storeName === 'router') {\n        return;\n      }\n      const store = __stores__[storeName];\n      if (hasInclude) {\n        let path = includeStores[storeName];\n        if (!path) {\n          const passPredicate = includeStores.fns.some(fn => fn(storeName));\n          if (passPredicate) {\n            path = storeName;\n          } else {\n            return;\n          }\n        }\n        setInitial(storeName, store, path);\n        subscribe(storeName, path);\n      } else {\n        setInitial(storeName, store, storeName);\n        subscribe(storeName, storeName);\n      }\n    }));\n    _persistStateInit.next(true);\n  });\n  return {\n    destroy() {\n      subscriptions.forEach(s => s.unsubscribe());\n      for (let i = 0, keys = Object.keys(stores); i < keys.length; i++) {\n        const storeName = keys[i];\n        stores[storeName].unsubscribe();\n      }\n      stores = {};\n    },\n    clear() {\n      storage.clear();\n    },\n    clearStore(storeName) {\n      if (isNil(storeName)) {\n        const value = observify(storage.setItem(key, '{}'));\n        value.subscribe();\n        return;\n      }\n      const value = storage.getItem(key);\n      observify(value).subscribe(v => {\n        const storageState = deserialize(v || '{}');\n        if (storageState[storeName]) {\n          delete storageState[storeName];\n          const value = observify(storage.setItem(key, serialize(storageState)));\n          value.subscribe();\n        }\n      });\n    }\n  };\n}\n//# sourceMappingURL=persistState.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}