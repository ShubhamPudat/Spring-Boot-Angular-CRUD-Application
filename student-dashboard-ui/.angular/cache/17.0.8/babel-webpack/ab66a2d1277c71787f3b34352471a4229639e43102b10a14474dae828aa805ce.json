{"ast":null,"code":"import { dirtyCheckDefaultParams, DirtyCheckPlugin, getNestedPath } from './dirtyCheckPlugin';\nimport { EntityCollectionPlugin } from '../entityCollectionPlugin';\nimport { auditTime, map, skip } from 'rxjs/operators';\nimport { merge, Subject } from 'rxjs';\nimport { coerceArray } from '../../coerceArray';\nexport class EntityDirtyCheckPlugin extends EntityCollectionPlugin {\n  constructor(query, params = {}) {\n    super(query, params.entityIds);\n    this.query = query;\n    this.params = params;\n    this._someDirty = new Subject();\n    this.someDirty$ = merge(this.query.select(state => state.entities), this._someDirty.asObservable()).pipe(auditTime(0), map(() => this.checkSomeDirty()));\n    this.params = {\n      ...dirtyCheckDefaultParams,\n      ...params\n    };\n    // TODO lazy activate?\n    this.activate();\n    this.selectIds().pipe(skip(1)).subscribe(ids => {\n      super.rebase(ids, {\n        afterAdd: plugin => plugin.setHead()\n      });\n    });\n  }\n  setHead(ids) {\n    if (this.params.entityIds && ids) {\n      const toArray = coerceArray(ids);\n      const someAreWatched = coerceArray(this.params.entityIds).some(id => toArray.indexOf(id) > -1);\n      if (someAreWatched === false) {\n        return this;\n      }\n    }\n    this.forEachId(ids, e => e.setHead());\n    this._someDirty.next(true);\n    return this;\n  }\n  hasHead(id) {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return entity.hasHead();\n    }\n    return false;\n  }\n  reset(ids, params = {}) {\n    this.forEachId(ids, e => e.reset(params));\n  }\n  isDirty(id, asObservable = true) {\n    if (this.entities.has(id)) {\n      const entity = this.getEntity(id);\n      return asObservable ? entity.isDirty$ : entity.isDirty();\n    }\n    return false;\n  }\n  someDirty() {\n    return this.checkSomeDirty();\n  }\n  isPathDirty(id, path) {\n    if (this.entities.has(id)) {\n      const head = this.getEntity(id).getHead();\n      const current = this.query.getEntity(id);\n      const currentPathValue = getNestedPath(current, path);\n      const headPathValue = getNestedPath(head, path);\n      return this.params.comparator(currentPathValue, headPathValue);\n    }\n    return null;\n  }\n  destroy(ids) {\n    this.forEachId(ids, e => e.destroy());\n    /** complete only when the plugin destroys */\n    if (!ids) {\n      this._someDirty.complete();\n    }\n  }\n  instantiatePlugin(id) {\n    return new DirtyCheckPlugin(this.query, this.params, id);\n  }\n  checkSomeDirty() {\n    const entitiesIds = this.resolvedIds();\n    for (const id of entitiesIds) {\n      if (this.getEntity(id).isDirty()) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n//# sourceMappingURL=entityDirtyCheckPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}