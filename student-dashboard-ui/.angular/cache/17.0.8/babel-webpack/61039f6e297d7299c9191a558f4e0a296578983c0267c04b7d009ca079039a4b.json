{"ast":null,"code":"import { HttpClient } from '@angular/common/http';\nimport * as i0 from '@angular/core';\nimport { Injectable, InjectionToken, inject } from '@angular/core';\nimport { isNumber, isString, isObject, isFunction, EntityService, isDefined } from '@datorama/akita';\nimport { Subject, ReplaySubject, isObservable, of, throwError } from 'rxjs';\nimport { filter, map, switchMap, tap, catchError, finalize } from 'rxjs/operators';\nfunction successAction(storeName, notifier) {\n  return function ({\n    payload,\n    method,\n    successMsg\n  }) {\n    notifier.dispatch({\n      type: 'success',\n      storeName,\n      payload,\n      method: method,\n      successMsg\n    });\n  };\n}\nfunction errorAction(storeName, notifier) {\n  return function ({\n    payload,\n    method,\n    errorMsg\n  }) {\n    notifier.dispatch({\n      type: 'error',\n      storeName,\n      payload,\n      method: method,\n      errorMsg\n    });\n  };\n}\nfunction isID(idOrConfig) {\n  return isNumber(idOrConfig) || isString(idOrConfig);\n}\nvar HttpMethod = /*#__PURE__*/function (HttpMethod) {\n  HttpMethod[\"GET\"] = \"GET\";\n  HttpMethod[\"POST\"] = \"POST\";\n  HttpMethod[\"PUT\"] = \"PUT\";\n  HttpMethod[\"PATCH\"] = \"PATCH\";\n  HttpMethod[\"DELETE\"] = \"DELETE\";\n  return HttpMethod;\n}(HttpMethod || {});\nconst ofType = type => filter(action => action.type === type);\nconst filterMethod = method => filter(action => action.method === method);\nconst filterStore = name => filter(action => action.storeName === name);\nlet NgEntityServiceNotifier = /*#__PURE__*/(() => {\n  class NgEntityServiceNotifier {\n    constructor() {\n      this.dispatcher = new Subject();\n      this.action$ = this.dispatcher.asObservable();\n    }\n    dispatch(event) {\n      this.dispatcher.next(event);\n    }\n  }\n  NgEntityServiceNotifier.ɵfac = function NgEntityServiceNotifier_Factory(t) {\n    return new (t || NgEntityServiceNotifier)();\n  };\n  NgEntityServiceNotifier.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgEntityServiceNotifier,\n    factory: NgEntityServiceNotifier.ɵfac,\n    providedIn: 'root'\n  });\n  return NgEntityServiceNotifier;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst NG_ENTITY_SERVICE_CONFIG = new InjectionToken('NgEntityServiceGlobalConfig');\nconst defaultConfig = {\n  httpMethods: {\n    GET: HttpMethod.GET,\n    POST: HttpMethod.POST,\n    PATCH: HttpMethod.PATCH,\n    PUT: HttpMethod.PUT,\n    DELETE: HttpMethod.DELETE\n  }\n};\nfunction mergeDeep(target, ...sources) {\n  if (!sources.length) return target;\n  const source = sources.shift();\n  if (isObject(target) && isObject(source)) {\n    for (const key in source) {\n      if (isObject(source[key])) {\n        if (!target[key]) Object.assign(target, {\n          [key]: {}\n        });\n        mergeDeep(target[key], source[key]);\n      } else {\n        Object.assign(target, {\n          [key]: source[key]\n        });\n      }\n    }\n  }\n  return mergeDeep(target, ...sources);\n}\nfunction NgEntityServiceConfig(config = {}) {\n  return function (constructor) {\n    if (config.baseUrl) {\n      constructor['baseUrl'] = config.baseUrl;\n    }\n    if (config.resourceName) {\n      constructor['resourceName'] = config.resourceName;\n    }\n  };\n}\nlet NgEntityServiceLoader = /*#__PURE__*/(() => {\n  class NgEntityServiceLoader {\n    constructor() {\n      this.dispatcher = new ReplaySubject(1);\n      this.loading$ = this.dispatcher.asObservable();\n    }\n    dispatch(event) {\n      this.dispatcher.next(event);\n    }\n    loadersFor(name) {\n      const filterStore = filter(({\n        storeName\n      }) => name ? storeName === name : true);\n      const filterMethod = mthd => filter(({\n        method\n      }) => {\n        return isFunction(mthd) ? mthd(method) : method === mthd;\n      });\n      const actionBased = current => this.loading$.pipe(filterStore, filterMethod(current), map(action => action.loading));\n      const idBased = (id, mthd) => this.loading$.pipe(filterStore, filterMethod(mthd), filter(action => action.entityId === id), map(action => action.loading));\n      return {\n        get$: actionBased(HttpMethod.GET),\n        add$: actionBased(HttpMethod.POST),\n        update$: actionBased(method => method === HttpMethod.PUT || method === HttpMethod.PATCH),\n        delete$: actionBased(HttpMethod.DELETE),\n        getEntity: id => idBased(id, HttpMethod.GET),\n        updateEntity: id => idBased(id, method => method === HttpMethod.PUT || method === HttpMethod.PATCH),\n        deleteEntity: id => idBased(id, HttpMethod.DELETE)\n      };\n    }\n  }\n  NgEntityServiceLoader.ɵfac = function NgEntityServiceLoader_Factory(t) {\n    return new (t || NgEntityServiceLoader)();\n  };\n  NgEntityServiceLoader.ɵprov = /* @__PURE__ */i0.ɵɵdefineInjectable({\n    token: NgEntityServiceLoader,\n    factory: NgEntityServiceLoader.ɵfac,\n    providedIn: 'root'\n  });\n  return NgEntityServiceLoader;\n})();\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nconst mapResponse = config => switchMap(res => {\n  const mappedResponse = !!config?.mapResponseFn ? config.mapResponseFn(res) : res;\n  return isObservable(mappedResponse) ? mappedResponse : of(mappedResponse);\n});\nclass NgEntityService extends EntityService {\n  constructor(store, config = {}) {\n    super();\n    this.store = store;\n    this.config = config;\n    this.http = inject(HttpClient);\n    this.loader = inject(NgEntityServiceLoader);\n    this.notifier = inject(NgEntityServiceNotifier);\n    const globalConfig = inject(NG_ENTITY_SERVICE_CONFIG);\n    this.mergedConfig = mergeDeep({}, defaultConfig, globalConfig, this.getDecoratorConfig(), config);\n    this.baseUrl = this.mergedConfig.baseUrl;\n    this.httpMethodMap = this.mergedConfig.httpMethods;\n    this.dispatchSuccess = successAction(this.store.storeName, this.notifier);\n    this.dispatchError = errorAction(this.store.storeName, this.notifier);\n  }\n  get api() {\n    if (!this.baseUrl) {\n      throw new Error(`baseUrl of ${this.constructor.name} is not defined.`);\n    }\n    return `${this.baseUrl}/${this.resourceName}`;\n  }\n  get resourceName() {\n    return this.mergedConfig.resourceName || this.store.storeName;\n  }\n  setBaseUrl(baseUrl) {\n    this.baseUrl = baseUrl;\n  }\n  getHttp() {\n    return this.http;\n  }\n  getConfig() {\n    return this.mergedConfig;\n  }\n  get(idOrConfig, config) {\n    const method = this.getHttpMethod(HttpMethod.GET);\n    const isSingle = isID(idOrConfig);\n    const entityId = isSingle ? idOrConfig : undefined;\n    const conf = (!isSingle ? idOrConfig : config) || {};\n    const url = this.resolveUrl(conf, entityId);\n    this.loader.dispatch({\n      method,\n      loading: true,\n      entityId,\n      storeName: this.store.storeName\n    });\n    return this.http.request(method, url, conf).pipe(mapResponse(conf), tap(data => {\n      if (!conf.skipWrite) {\n        if (isSingle) {\n          this.store.upsert(entityId, data, (id, newState) => ({\n            id,\n            ...newState\n          }));\n        } else {\n          if (conf.append) {\n            this.store.add(data);\n          } else if (conf.upsert) {\n            this.store.upsertMany(data);\n          } else {\n            this.store.set(data);\n          }\n        }\n      }\n      this.dispatchSuccess({\n        method,\n        payload: data,\n        successMsg: conf.successMsg\n      });\n    }), catchError(error => this.handleError(method, error, conf.errorMsg)), finalize(() => {\n      this.loader.dispatch({\n        method,\n        loading: false,\n        entityId,\n        storeName: this.store.storeName\n      });\n    }));\n  }\n  /**\n   * Add a new entity - Creates a POST request\n   *\n   * @example\n   * service.add(entity).subscribe()\n   * service.add(entity, config).subscribe()\n   */\n  add(entity, config) {\n    const url = this.resolveUrl(config);\n    const method = this.getHttpMethod(HttpMethod.POST);\n    this.loader.dispatch({\n      method,\n      loading: true,\n      storeName: this.store.storeName\n    });\n    const configWithBody = {\n      ...config,\n      ...{\n        body: entity\n      }\n    };\n    return this.http.request(method, url, configWithBody).pipe(mapResponse(config), tap(responseEntity => {\n      if (!config || config && !config.skipWrite) {\n        this.store.add(responseEntity, config);\n      }\n      this.dispatchSuccess({\n        method,\n        payload: responseEntity,\n        successMsg: config && config.successMsg\n      });\n    }), catchError(error => this.handleError(method, error, config && config.errorMsg)), finalize(() => {\n      this.loader.dispatch({\n        method,\n        loading: false,\n        storeName: this.store.storeName\n      });\n    }));\n  }\n  /**\n   * Update an entity - Creates a PUT/PATCH request\n   *\n   * @example\n   * service.update(id, entity).subscribe()\n   * service.update(id, entity, config).subscribe()\n   */\n  update(id, entity, config) {\n    const url = this.resolveUrl(config, id);\n    const method = config && config.method || this.getHttpMethod(HttpMethod.PUT);\n    this.loader.dispatch({\n      method,\n      loading: true,\n      entityId: id,\n      storeName: this.store.storeName\n    });\n    const configWithBody = {\n      ...config,\n      ...{\n        body: entity\n      }\n    };\n    return this.http.request(method, url, configWithBody).pipe(mapResponse(config), tap(responseEntity => {\n      if (!config || config && !config.skipWrite) {\n        this.store.update(id, responseEntity);\n      }\n      this.dispatchSuccess({\n        method,\n        payload: responseEntity,\n        successMsg: config && config.successMsg\n      });\n    }), catchError(error => this.handleError(method, error, config && config.errorMsg)), finalize(() => {\n      this.loader.dispatch({\n        method,\n        loading: false,\n        entityId: id,\n        storeName: this.store.storeName\n      });\n    }));\n  }\n  /**\n   * Delete an entity - Creates a DELETE request\n   *\n   * @example\n   * service.delete(id).subscribe()\n   * service.delete(id, config).subscribe()\n   */\n  delete(id, config) {\n    const url = this.resolveUrl(config, id);\n    const method = this.getHttpMethod(HttpMethod.DELETE);\n    this.loader.dispatch({\n      method,\n      loading: true,\n      entityId: id,\n      storeName: this.store.storeName\n    });\n    return this.http.request(method, url, config).pipe(mapResponse(config), tap(res => {\n      if (!config || config && !config.skipWrite) {\n        this.store.remove(id);\n      }\n      this.dispatchSuccess({\n        method,\n        payload: res,\n        successMsg: config && config.successMsg\n      });\n    }), catchError(error => this.handleError(method, error, config && config.errorMsg)), finalize(() => {\n      this.loader.dispatch({\n        method,\n        loading: false,\n        entityId: id,\n        storeName: this.store.storeName\n      });\n    }));\n  }\n  /**\n   * Gets the mapped HttpMethod.\n   *\n   * The default HttpMethod can be changed like so:\n   * ```ts\n   * {\n   *   provide: NG_ENTITY_SERVICE_CONFIG,\n   *   useValue: {\n   *     httpMethods: {\n   *       PUT: HttpMethod.PATCH,\n   *     },\n   *   } as NgEntityServiceGlobalConfig,\n   * }\n   * ```\n   *\n   * @param type HttpMethod to get the user configured HttpMethod for\n   * @returns User configured HttpMethod for the method, else the default HttpMethod\n   */\n  getHttpMethod(type) {\n    let httpMethod;\n    if (this.httpMethodMap) {\n      httpMethod = this.httpMethodMap[type];\n    }\n    if (!httpMethod) {\n      throw new Error('Unknown HttpMethod');\n    }\n    return httpMethod;\n  }\n  /**\n   * Gets the value given via the NgEntityServiceConfig decorator\n   *\n   * ```ts\n   * @NgEntityServiceConfig({\n   *   baseUrl: 'foo',\n   *   resourceName: 'bar',\n   * })\n   * ```\n   *\n   * @param key The property key\n   * @returns The value of the given decorator key\n   */\n  getDecoratorValue(key) {\n    return this.constructor[key];\n  }\n  getDecoratorConfig() {\n    const config = {};\n    const baseUrl = this.getDecoratorValue('baseUrl');\n    if (baseUrl) {\n      config.baseUrl = baseUrl;\n    }\n    const resourceName = this.getDecoratorValue('resourceName');\n    if (resourceName) {\n      config.resourceName = resourceName;\n    }\n    return config;\n  }\n  resolveUrl(config, id) {\n    const {\n      url,\n      urlPostfix\n    } = Object(config);\n    let final = this.api;\n    if (url) {\n      return url;\n    }\n    if (isDefined(id)) {\n      final += `/${id}`;\n    }\n    if (urlPostfix) {\n      final += `/${urlPostfix}`;\n    }\n    return final;\n  }\n  handleError(method, error, errorMsg) {\n    this.dispatchError({\n      method,\n      errorMsg,\n      payload: error\n    });\n    return throwError(error);\n  }\n}\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { HttpMethod, NG_ENTITY_SERVICE_CONFIG, NgEntityService, NgEntityServiceConfig, NgEntityServiceLoader, NgEntityServiceNotifier, defaultConfig, errorAction, filterMethod, filterStore, isID, mapResponse, mergeDeep, ofType, successAction };\n//# sourceMappingURL=datorama-akita-ng-entity-service.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}