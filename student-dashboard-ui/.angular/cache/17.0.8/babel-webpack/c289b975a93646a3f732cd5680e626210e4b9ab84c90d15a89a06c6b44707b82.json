{"ast":null,"code":"import { pairwise, distinctUntilChanged } from 'rxjs/operators';\nimport { BehaviorSubject } from 'rxjs';\nimport { AkitaPlugin } from '../plugin';\nimport { logAction } from '../../actions';\nimport { isFunction } from '../../isFunction';\nexport class StateHistoryPlugin extends AkitaPlugin {\n  constructor(query, params = {}, _entityId) {\n    super(query, {\n      resetFn: () => this.clear()\n    });\n    this.query = query;\n    this.params = params;\n    this._entityId = _entityId;\n    /** Allow skipping an update from outside */\n    this.skip = false;\n    this.history = {\n      past: [],\n      present: null,\n      future: []\n    };\n    /** Skip the update when redo/undo */\n    this.skipUpdate = false;\n    params.maxAge = !!params.maxAge ? params.maxAge : 10;\n    params.comparator = params.comparator || (() => true);\n    this.activate();\n  }\n  /**\n   * Observable stream representing whether the history plugin has an available past\n   *\n   */\n  get hasPast$() {\n    return this._hasPast$;\n  }\n  /**\n   * Observable stream representing whether the history plugin has an available future\n   *\n   */\n  get hasFuture$() {\n    return this._hasFuture$;\n  }\n  get hasPast() {\n    return this.history.past.length > 0;\n  }\n  get hasFuture() {\n    return this.history.future.length > 0;\n  }\n  get property() {\n    return this.params.watchProperty;\n  }\n  /* Updates the hasPast$ hasFuture$ observables*/\n  updateHasHistory() {\n    this.hasFutureSubject.next(this.hasFuture);\n    this.hasPastSubject.next(this.hasPast);\n  }\n  activate() {\n    this.hasPastSubject = new BehaviorSubject(false);\n    this._hasPast$ = this.hasPastSubject.asObservable().pipe(distinctUntilChanged());\n    this.hasFutureSubject = new BehaviorSubject(false);\n    this._hasFuture$ = this.hasFutureSubject.asObservable().pipe(distinctUntilChanged());\n    this.history.present = this.getSource(this._entityId, this.property);\n    this.subscription = this.selectSource(this._entityId, this.property).pipe(pairwise()).subscribe(([past, present]) => {\n      if (this.skip) {\n        this.skip = false;\n        return;\n      }\n      /**\n       *  comparator: (prev, current) => isEqual(prev, current) === false\n       */\n      const shouldUpdate = this.params.comparator(past, present);\n      if (!this.skipUpdate && shouldUpdate) {\n        if (this.history.past.length === this.params.maxAge) {\n          this.history.past = this.history.past.slice(1);\n        }\n        this.history.past = [...this.history.past, past];\n        this.history.present = present;\n        this.updateHasHistory();\n      }\n    });\n  }\n  undo() {\n    if (this.history.past.length > 0) {\n      const {\n        past,\n        present\n      } = this.history;\n      const previous = past[past.length - 1];\n      this.history.past = past.slice(0, past.length - 1);\n      this.history.present = previous;\n      this.history.future = [present, ...this.history.future];\n      this.update();\n    }\n  }\n  redo() {\n    if (this.history.future.length > 0) {\n      const {\n        past,\n        present\n      } = this.history;\n      const next = this.history.future[0];\n      const newFuture = this.history.future.slice(1);\n      this.history.past = [...past, present];\n      this.history.present = next;\n      this.history.future = newFuture;\n      this.update('Redo');\n    }\n  }\n  jumpToPast(index) {\n    if (index < 0 || index >= this.history.past.length) return;\n    const {\n      past,\n      future,\n      present\n    } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9];\n     * const index = 2;\n     *\n     * newPast = past.slice(0, index) = [1, 2];\n     * newPresent = past[index] = 3;\n     * newFuture = [...past.slice(index + 1),present, ...future] = [4, 5, 6, 7, 8, 9];\n     *\n     */\n    const newPast = past.slice(0, index);\n    const newFuture = [...past.slice(index + 1), present, ...future];\n    const newPresent = past[index];\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update();\n  }\n  jumpToFuture(index) {\n    if (index < 0 || index >= this.history.future.length) return;\n    const {\n      past,\n      future,\n      present\n    } = this.history;\n    /**\n     *\n     * const past = [1, 2, 3, 4, 5];\n     * const present = 6;\n     * const future = [7, 8, 9, 10]\n     * const index = 1\n     *\n     * newPast = [...past, present, ...future.slice(0, index) = [1, 2, 3, 4, 5, 6, 7];\n     * newPresent = future[index] = 8;\n     * newFuture = futrue.slice(index+1) = [9, 10];\n     *\n     */\n    const newPast = [...past, present, ...future.slice(0, index)];\n    const newPresent = future[index];\n    const newFuture = future.slice(index + 1);\n    this.history.past = newPast;\n    this.history.present = newPresent;\n    this.history.future = newFuture;\n    this.update('Redo');\n  }\n  /**\n   *\n   * jump n steps in the past or forward\n   *\n   */\n  jump(n) {\n    if (n > 0) return this.jumpToFuture(n - 1);\n    if (n < 0) return this.jumpToPast(this.history.past.length + n);\n  }\n  /**\n   * Clear the history\n   *\n   * @param customUpdateFn Callback function for only clearing part of the history\n   *\n   * @example\n   *\n   * stateHistory.clear((history) => {\n   *  return {\n   *    past: history.past,\n   *    present: history.present,\n   *    future: []\n   *  };\n   * });\n   */\n  clear(customUpdateFn) {\n    this.history = isFunction(customUpdateFn) ? customUpdateFn(this.history) : {\n      past: [],\n      present: null,\n      future: []\n    };\n    this.updateHasHistory();\n  }\n  destroy(clearHistory = false) {\n    if (clearHistory) {\n      this.clear();\n    }\n    this.subscription.unsubscribe();\n  }\n  ignoreNext() {\n    this.skip = true;\n  }\n  update(action = 'Undo') {\n    this.skipUpdate = true;\n    logAction(`@StateHistory - ${action}`);\n    this.updateStore(this.history.present, this._entityId, this.property, true);\n    this.updateHasHistory();\n    this.skipUpdate = false;\n  }\n}\n//# sourceMappingURL=stateHistoryPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}