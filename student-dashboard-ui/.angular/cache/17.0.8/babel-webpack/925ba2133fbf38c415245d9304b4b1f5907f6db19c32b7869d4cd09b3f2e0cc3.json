{"ast":null,"code":"import { __decorate, __metadata } from \"tslib\";\nimport { BehaviorSubject, from, isObservable } from 'rxjs';\nimport { delay, map, switchMap, take } from 'rxjs/operators';\nimport { action, logAction } from '../../actions';\nimport { isNil } from '../../isNil';\nimport { isUndefined } from '../../isUndefined';\nimport { applyTransaction } from '../../transaction';\nimport { AkitaPlugin } from '../plugin';\nconst paginatorDefaults = {\n  pagesControls: false,\n  range: false,\n  startWith: 1,\n  cacheTimeout: undefined,\n  clearStoreWithCache: true\n};\nexport class PaginatorPlugin extends AkitaPlugin {\n  constructor(query, config = {}) {\n    super(query, {\n      resetFn: () => {\n        this.initial = false;\n        this.destroy({\n          clearCache: true,\n          currentPage: 1\n        });\n      }\n    });\n    this.query = query;\n    this.config = config;\n    /** Save current filters, sorting, etc. in cache */\n    this.metadata = new Map();\n    this.pages = new Map();\n    this.pagination = {\n      currentPage: 1,\n      perPage: 0,\n      total: 0,\n      lastPage: 0,\n      data: []\n    };\n    /**\n     * When the user navigates to a different page and return\n     * we don't want to call `clearCache` on first time.\n     */\n    this.initial = true;\n    /**\n     * Proxy to the query loading\n     */\n    this.isLoading$ = this.query.selectLoading().pipe(delay(0));\n    this.config = {\n      ...paginatorDefaults,\n      ...config\n    };\n    const {\n      startWith,\n      cacheTimeout\n    } = this.config;\n    this.page = new BehaviorSubject(startWith);\n    if (isObservable(cacheTimeout)) {\n      this.clearCacheSubscription = cacheTimeout.subscribe(() => this.clearCache());\n    }\n  }\n  /**\n   * Listen to page changes\n   */\n  get pageChanges() {\n    return this.page.asObservable();\n  }\n  /**\n   * Get the current page number\n   */\n  get currentPage() {\n    return this.pagination.currentPage;\n  }\n  /**\n   * Check if current page is the first one\n   */\n  get isFirst() {\n    return this.currentPage === 1;\n  }\n  /**\n   * Check if current page is the last one\n   */\n  get isLast() {\n    return this.currentPage === this.pagination.lastPage;\n  }\n  /**\n   * Whether to generate an array of pages for *ngFor\n   * [1, 2, 3, 4]\n   */\n  withControls() {\n    this.config.pagesControls = true;\n    return this;\n  }\n  /**\n   * Whether to generate the `from` and `to` keys\n   * [1, 2, 3, 4]\n   */\n  withRange() {\n    this.config.range = true;\n    return this;\n  }\n  /**\n   * Set the loading state\n   */\n  setLoading(value = true) {\n    this.getStore().setLoading(value);\n  }\n  /**\n   * Update the pagination object and add the page\n   */\n  update(response) {\n    this.pagination = response;\n    this.addPage(response.data);\n  }\n  /**\n   *\n   * Set the ids and add the page to store\n   */\n  addPage(data) {\n    this.pages.set(this.currentPage, {\n      ids: data.map(entity => entity[this.getStore().idKey])\n    });\n    this.getStore().upsertMany(data);\n  }\n  /**\n   * Clear the cache.\n   */\n  clearCache(options = {}) {\n    if (!this.initial) {\n      logAction('@Pagination - Clear Cache');\n      if (options.clearStore !== false && (this.config.clearStoreWithCache || options.clearStore)) {\n        this.getStore().remove();\n      }\n      this.pages = new Map();\n      this.metadata = new Map();\n    }\n    this.initial = false;\n  }\n  clearPage(page) {\n    this.pages.delete(page);\n  }\n  /**\n   * Clear the cache timeout and optionally the pages\n   */\n  destroy({\n    clearCache,\n    currentPage\n  } = {}) {\n    if (this.clearCacheSubscription) {\n      this.clearCacheSubscription.unsubscribe();\n    }\n    if (clearCache) {\n      this.clearCache();\n    }\n    if (!isUndefined(currentPage)) {\n      this.setPage(currentPage);\n    }\n    this.initial = true;\n  }\n  /**\n   * Whether the provided page is active\n   */\n  isPageActive(page) {\n    return this.currentPage === page;\n  }\n  /**\n   * Set the current page\n   */\n  setPage(page) {\n    if (page !== this.currentPage || !this.hasPage(page)) {\n      this.page.next(this.pagination.currentPage = page);\n    }\n  }\n  /**\n   * Increment current page\n   */\n  nextPage() {\n    if (this.currentPage !== this.pagination.lastPage) {\n      this.setPage(this.pagination.currentPage + 1);\n    }\n  }\n  /**\n   * Decrement current page\n   */\n  prevPage() {\n    if (this.pagination.currentPage > 1) {\n      this.setPage(this.pagination.currentPage - 1);\n    }\n  }\n  /**\n   * Set current page to last\n   */\n  setLastPage() {\n    this.setPage(this.pagination.lastPage);\n  }\n  /**\n   * Set current page to first\n   */\n  setFirstPage() {\n    this.setPage(1);\n  }\n  /**\n   * Check if page exists in cache\n   */\n  hasPage(page) {\n    return this.pages.has(page);\n  }\n  /**\n   * Get the current page if it's in cache, otherwise invoke the request\n   */\n  getPage(req) {\n    let page = this.pagination.currentPage;\n    if (this.hasPage(page)) {\n      return this.selectPage(page);\n    } else {\n      this.setLoading(true);\n      return from(req()).pipe(switchMap(config => {\n        page = config.currentPage;\n        applyTransaction(() => {\n          this.setLoading(false);\n          this.update(config);\n        });\n        return this.selectPage(page);\n      }));\n    }\n  }\n  getQuery() {\n    return this.query;\n  }\n  refreshCurrentPage() {\n    if (isNil(this.currentPage) === false) {\n      this.clearPage(this.currentPage);\n      this.setPage(this.currentPage);\n    }\n  }\n  getFrom() {\n    if (this.isFirst) {\n      return 1;\n    }\n    return (this.currentPage - 1) * this.pagination.perPage + 1;\n  }\n  getTo() {\n    if (this.isLast) {\n      return this.pagination.total;\n    }\n    return this.currentPage * this.pagination.perPage;\n  }\n  /**\n   * Select the page\n   */\n  selectPage(page) {\n    return this.query.selectAll({\n      asObject: true\n    }).pipe(take(1), map(entities => {\n      const response = {\n        ...this.pagination,\n        data: this.pages.get(page).ids.map(id => entities[id])\n      };\n      const {\n        range,\n        pagesControls\n      } = this.config;\n      /** If no total - calc it */\n      if (isNaN(this.pagination.total)) {\n        if (response.lastPage === 1) {\n          response.total = response.data ? response.data.length : 0;\n        } else {\n          response.total = response.perPage * response.lastPage;\n        }\n        this.pagination.total = response.total;\n      }\n      if (range) {\n        response.from = this.getFrom();\n        response.to = this.getTo();\n      }\n      if (pagesControls) {\n        response.pageControls = generatePages(this.pagination.total, this.pagination.perPage);\n      }\n      return response;\n    }));\n  }\n}\n__decorate([action('@Pagination - New Page'), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", [Object]), __metadata(\"design:returntype\", void 0)], PaginatorPlugin.prototype, \"update\", null);\n/**\n * Generate an array so we can ngFor them to navigate between pages\n */\nfunction generatePages(total, perPage) {\n  const len = Math.ceil(total / perPage);\n  const arr = [];\n  for (let i = 0; i < len; i++) {\n    arr.push(i + 1);\n  }\n  return arr;\n}\n/** backward compatibility */\nexport const Paginator = PaginatorPlugin;\n//# sourceMappingURL=paginatorPlugin.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}