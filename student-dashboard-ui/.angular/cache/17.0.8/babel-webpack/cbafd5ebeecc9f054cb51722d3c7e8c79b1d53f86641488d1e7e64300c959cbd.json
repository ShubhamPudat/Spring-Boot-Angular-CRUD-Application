{"ast":null,"code":"import { merge, of } from 'rxjs';\nimport { filter, first, switchMap, tap } from 'rxjs/operators';\n/**\n * Track id updates of an entity and re-evaluation the query with the changed entity id.\n * Hint: Don't place the operator after other operators in the same pipeline as those will be skipped on\n * re-evaluation. Also, it can't be used with the selection operator, e.g <code>selectEntity(1, e => e.title)</code>\n * @param query The query from which the entity is selected.\n * @example\n *\n *   query.selectEntity(1).pipe(trackIdChanges(query)).subscribe(entity => { ... })\n *\n */\nexport function trackIdChanges(query) {\n  return source => source.lift(new TrackIdChanges(query));\n}\nclass TrackIdChanges {\n  constructor(query) {\n    this.query = query;\n  }\n  call(subscriber, source) {\n    return source.pipe(first(), switchMap(entity => {\n      let currId = entity[this.query.__store__.config.idKey];\n      let pending = false;\n      return merge(of({\n        newId: undefined,\n        oldId: currId,\n        pending: false\n      }), this.query.__store__.selectEntityIdChanges$).pipe(\n      // the new id must differ form the old id\n      filter(change => change.oldId === currId),\n      // extract the current pending state of the id update\n      tap(change => pending = change.pending),\n      // only update the selection query if the id update is already applied to the store\n      filter(change => change.newId !== currId && !pending),\n      // build a selection query for the new entity id\n      switchMap(change => this.query.selectEntity(currId = change.newId || currId)\n      // skip undefined value if pending.\n      .pipe(filter(() => !pending))));\n    })).subscribe(subscriber);\n  }\n}\n//# sourceMappingURL=trackIdChanges.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}