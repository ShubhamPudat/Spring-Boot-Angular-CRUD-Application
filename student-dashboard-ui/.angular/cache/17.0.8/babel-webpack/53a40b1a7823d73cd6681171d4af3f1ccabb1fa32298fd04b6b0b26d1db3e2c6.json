{"ast":null,"code":"import { BehaviorSubject } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\nimport { currentAction, resetCustomAction, setAction } from './actions';\nimport { getAkitaConfig, getGlobalProducerFn } from './config';\nimport { deepFreeze } from './deepFreeze';\nimport { dispatchAdded, dispatchDeleted, dispatchUpdate } from './dispatchers';\nimport { isDev, __DEV__ } from './env';\nimport { assertStoreHasName } from './errors';\nimport { isDefined } from './isDefined';\nimport { isFunction } from './isFunction';\nimport { isPlainObject } from './isPlainObject';\nimport { isBrowser } from './root';\nimport { configKey } from './storeConfig';\nimport { __stores__ } from './stores';\nimport { commit, isTransactionInProcess } from './transaction';\n/**\n *\n * Store for managing any type of data\n *\n * @example\n *\n * export interface SessionState {\n *   token: string;\n *   userDetails: UserDetails\n * }\n *\n * export function createInitialState(): SessionState {\n *  return {\n *    token: '',\n *    userDetails: null\n *  };\n * }\n *\n * @StoreConfig({ name: 'session' })\n * export class SessionStore extends Store<SessionState> {\n *   constructor() {\n *    super(createInitialState());\n *   }\n * }\n */\nexport class Store {\n  constructor(initialState, options = {}) {\n    this.options = options;\n    this.inTransaction = false;\n    this.cache = {\n      active: new BehaviorSubject(false),\n      ttl: null\n    };\n    this.onInit(initialState);\n  }\n  /**\n   *  Set the loading state\n   *\n   *  @example\n   *\n   *  store.setLoading(true)\n   *\n   */\n  setLoading(loading = false) {\n    if (loading !== this._value().loading) {\n      isDev() && setAction('Set Loading');\n      this._setState(state => ({\n        ...state,\n        loading\n      }));\n    }\n  }\n  /**\n   *\n   * Set whether the data is cached\n   *\n   * @example\n   *\n   * store.setHasCache(true)\n   * store.setHasCache(false)\n   * store.setHasCache(true, { restartTTL: true })\n   *\n   */\n  setHasCache(hasCache, options = {\n    restartTTL: false\n  }) {\n    if (hasCache !== this.cache.active.value) {\n      this.cache.active.next(hasCache);\n    }\n    if (options.restartTTL) {\n      const ttlConfig = this.getCacheTTL();\n      if (ttlConfig) {\n        if (this.cache.ttl !== null) {\n          clearTimeout(this.cache.ttl);\n        }\n        this.cache.ttl = setTimeout(() => this.setHasCache(false), ttlConfig);\n      }\n    }\n  }\n  /**\n   *\n   * Sometimes we need to access the store value from a store\n   *\n   * @example middleware\n   *\n   */\n  getValue() {\n    return this.storeValue;\n  }\n  /**\n   *  Set the error state\n   *\n   *  @example\n   *\n   *  store.setError({text: 'unable to load data' })\n   *\n   */\n  setError(error) {\n    if (error !== this._value().error) {\n      isDev() && setAction('Set Error');\n      this._setState(state => ({\n        ...state,\n        error\n      }));\n    }\n  }\n  // @internal\n  _select(project) {\n    return this.store.asObservable().pipe(map(snapshot => project(snapshot.state)), distinctUntilChanged());\n  }\n  // @internal\n  _value() {\n    return this.storeValue;\n  }\n  // @internal\n  _cache() {\n    return this.cache.active;\n  }\n  // @internal\n  get config() {\n    return this.constructor[configKey] || {};\n  }\n  // @internal\n  get storeName() {\n    return this.config.storeName || this.options.storeName || this.options.name;\n  }\n  // @internal\n  get deepFreeze() {\n    return this.config.deepFreezeFn || this.options.deepFreezeFn || deepFreeze;\n  }\n  // @internal\n  get cacheConfig() {\n    return this.config.cache || this.options.cache;\n  }\n  get _producerFn() {\n    return this.config.producerFn || this.options.producerFn || getGlobalProducerFn();\n  }\n  // @internal\n  get resettable() {\n    return isDefined(this.config.resettable) ? this.config.resettable : this.options.resettable;\n  }\n  // @internal\n  _setState(newState, _dispatchAction = true) {\n    if (isFunction(newState)) {\n      const _newState = newState(this._value());\n      this.storeValue = __DEV__ ? this.deepFreeze(_newState) : _newState;\n    } else {\n      this.storeValue = newState;\n    }\n    if (!this.store) {\n      this.store = new BehaviorSubject({\n        state: this.storeValue\n      });\n      if (isDev()) {\n        this.store.subscribe(({\n          action\n        }) => {\n          if (action) {\n            dispatchUpdate(this.storeName, action);\n          }\n        });\n      }\n      return;\n    }\n    if (isTransactionInProcess()) {\n      this.handleTransaction();\n      return;\n    }\n    this.dispatch(this.storeValue, _dispatchAction);\n  }\n  /**\n   *\n   * Reset the current store back to the initial value\n   *\n   * @example\n   *\n   * store.reset()\n   *\n   */\n  reset() {\n    if (this.isResettable()) {\n      isDev() && setAction('Reset');\n      this._setState(() => Object.assign({}, this._initialState));\n      this.setHasCache(false);\n    }\n  }\n  update(stateOrCallback) {\n    isDev() && setAction('Update');\n    let newState;\n    const currentState = this._value();\n    if (isFunction(stateOrCallback)) {\n      newState = isFunction(this._producerFn) ? this._producerFn(currentState, stateOrCallback) : stateOrCallback(currentState);\n    } else {\n      newState = stateOrCallback;\n    }\n    const withHook = this.akitaPreUpdate(currentState, {\n      ...currentState,\n      ...newState\n    });\n    const resolved = isPlainObject(currentState) ? withHook : new currentState.constructor(withHook);\n    this._setState(resolved);\n  }\n  updateStoreConfig(newOptions) {\n    this.options = {\n      ...this.options,\n      ...newOptions\n    };\n  }\n  // @internal\n  akitaPreUpdate(_, nextState) {\n    return nextState;\n  }\n  /**\n   *\n   * Destroy the store\n   *\n   * @example\n   *\n   * store.destroy()\n   *\n   */\n  destroy() {\n    const hmrEnabled = isBrowser ? window.hmrEnabled : false;\n    if (!hmrEnabled && this === __stores__[this.storeName]) {\n      delete __stores__[this.storeName];\n      dispatchDeleted(this.storeName);\n      this.setHasCache(false);\n      this.cache.active.complete();\n      this.store.complete();\n    }\n  }\n  onInit(initialState) {\n    __stores__[this.storeName] = this;\n    this._setState(() => initialState);\n    dispatchAdded(this.storeName);\n    if (this.isResettable()) {\n      this._initialState = initialState;\n    }\n    isDev() && assertStoreHasName(this.storeName, this.constructor.name);\n  }\n  dispatch(state, _dispatchAction = true) {\n    let action = undefined;\n    if (_dispatchAction) {\n      action = currentAction;\n      resetCustomAction();\n    }\n    this.store.next({\n      state,\n      action\n    });\n  }\n  watchTransaction() {\n    commit().subscribe(() => {\n      this.inTransaction = false;\n      this.dispatch(this._value());\n    });\n  }\n  isResettable() {\n    if (this.resettable === false) {\n      return false;\n    }\n    return this.resettable || getAkitaConfig().resettable;\n  }\n  handleTransaction() {\n    if (!this.inTransaction) {\n      this.watchTransaction();\n      this.inTransaction = true;\n    }\n  }\n  getCacheTTL() {\n    return this.cacheConfig && this.cacheConfig.ttl || getAkitaConfig().ttl;\n  }\n}\n//# sourceMappingURL=store.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}