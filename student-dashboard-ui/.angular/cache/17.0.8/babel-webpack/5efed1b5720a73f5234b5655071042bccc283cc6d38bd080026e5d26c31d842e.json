{"ast":null,"code":"import { BehaviorSubject, of, Subject } from 'rxjs';\nimport { logAction } from './actions';\nimport { tap } from 'rxjs/operators';\n// @internal\nconst transactionFinished = new Subject();\n// @internal\nconst transactionInProcess = new BehaviorSubject(false);\n// @internal\nexport const transactionManager = {\n  activeTransactions: 0,\n  batchTransaction: null\n};\n// @internal\nexport function startBatch() {\n  if (!isTransactionInProcess()) {\n    transactionManager.batchTransaction = new Subject();\n  }\n  transactionManager.activeTransactions++;\n  transactionInProcess.next(true);\n}\n// @internal\nexport function endBatch() {\n  if (--transactionManager.activeTransactions === 0) {\n    transactionManager.batchTransaction.next(true);\n    transactionManager.batchTransaction.complete();\n    transactionInProcess.next(false);\n    transactionFinished.next(true);\n  }\n}\n// @internal\nexport function isTransactionInProcess() {\n  return transactionManager.activeTransactions > 0;\n}\n// @internal\nexport function commit() {\n  return transactionManager.batchTransaction ? transactionManager.batchTransaction.asObservable() : of(true);\n}\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *  The following code will update the store, BUT  emits only once\n *\n *  @example\n *  applyTransaction(() => {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  });\n *\n */\nexport function applyTransaction(action, thisArg = undefined) {\n  startBatch();\n  try {\n    return action.apply(thisArg);\n  } finally {\n    logAction('@Transaction');\n    endBatch();\n  }\n}\n/**\n *  A logical transaction.\n *  Use this transaction to optimize the dispatch of all the stores.\n *\n *  The following code will update the store, BUT  emits only once.\n *\n *  @example\n *  @transaction\n *  addTodos() {\n *    this.todosStore.add(new Todo(1, title));\n *    this.todosStore.add(new Todo(2, title));\n *  }\n *\n *\n */\nexport function transaction() {\n  return function (target, propertyKey, descriptor) {\n    const originalMethod = descriptor.value;\n    descriptor.value = function (...args) {\n      return applyTransaction(() => {\n        return originalMethod.apply(this, args);\n      }, this);\n    };\n    return descriptor;\n  };\n}\n/**\n *\n * RxJS custom operator that wraps the callback inside transaction\n *\n * @example\n *\n * return http.get().pipe(\n *    withTransaction(response > {\n *      store.setActive(1);\n *      store.update();\n *      store.updateEntity(1, {});\n *    })\n * )\n *\n */\nexport function withTransaction(next) {\n  return function (source) {\n    return source.pipe(tap(value => applyTransaction(() => next(value))));\n  };\n}\n//# sourceMappingURL=transaction.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}